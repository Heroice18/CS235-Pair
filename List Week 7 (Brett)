//
//  list.h
//  Assignment 7
//
//  Created by Brett Mills on 2/18/19.
//  Copyright Â© 2019 Brett Mills. All rights reserved.
//

#ifndef list_h
#define list_h

#include <cstddef>
#include <iostream>

using namespace std;

#ifdef UNIT_TESTING
int main(int argc, const char* argv[]);
#endif

namespace custom
{
    template <class T>
    class list
    {
    private:
        /*******************************************
         * Node Class
         *******************************************/
        class node
        {
            friend list;
        private:
            #ifdef UNIT_TESTING
                friend int ::main(int argc, const char* argv[]);
            #endif
            
            T data;
            node * pNext;
            node * pPrev;
            friend class iterator;
            node()
            {
                data  = NULL;
                pNext = NULL;
                pPrev = NULL;
            }
            node(T t)
            {
                data  = t;
                pNext = NULL;
                pPrev = NULL;
            }
        };
        
        // list private data
        node * pHead;
        node * pTail;
        int    numElements;
        
    public:
        // for testing purposes
        #ifdef UNIT_TESTING
            friend int ::main(int argc, const char* argv[]);
        #endif
        
        // constructors
        list();
        list(const list & rhs);
        ~list();
        
        // operators
        list <T> & operator=(const list & rhs);
        
        // standard container interfaces
        int  size()  { return numElements; }
        bool empty() { return pHead == NULL; }
        void clear();
        
        // list specific
        void push_front(const T t);
        void push_back (const T t);
        void pop_front();
        void pop_back();
        
        T & front()       throw(const char *); // might not need
        T   front() const throw(const char *);
        
        T & back()        throw(const char *); // might not need
        T   back()  const throw(const char *);
        
        // iterator stuff
        class iterator;
        // fix these when I can, they don't actually return NULL
        // can't figure out syntax to create function
        iterator erase(iterator it) { return NULL; }
        iterator insert(iterator & it, const T & data) throw(const char *);
        //        iterator insert(iterator & it, const T & data) throw(const char *);
        
        iterator find(T t) { return NULL; }
        
        
        iterator begin() { return iterator(pHead); }
        iterator end()   { return iterator(NULL);  }
        
        /*******************************************
         * Iterator Class
         *******************************************/
        class iterator
        {
            friend list;
            friend node;
        private:
            typename list <T> :: node * ptr;
            
        public:
            // for testing purposes
            #ifdef UNIT_TESTING
                friend int ::main(int argc, const char* argv[]);
            #endif
            
            // constructors, destructors, and assignment operator
            iterator()           : ptr(NULL)        {              }
            iterator(node * ptr) : ptr(ptr)         {              }
            iterator(const iterator & rhs) { *this = rhs; }
            iterator & operator = (const iterator & rhs)
            {
                this->ptr = rhs.ptr;
                return *this;
            }
            // equals, not equals operator
            bool operator != (const iterator & rhs) const { return rhs.ptr != this->ptr; }
            bool operator == (const iterator & rhs) const { return rhs.ptr == this->ptr; }
            
            T & operator * ()             { return ptr->data; }
            const T & operator * () const { return ptr->data; }
            
            // prefix increment
            iterator & operator ++ ()
            {
                // check if ptr is not NULL
                if (ptr)
                {
                    ptr++;
                }
                return *this;
            }
            // postfix increment
            iterator operator ++ (int postfix)
            {
                // check if ptr is not NULL
                if (ptr)
                {
                    iterator tmp(*this);
                    ptr++;
                    return tmp;
                }
                else
                    return *this;
            }
            // prefix decrement
            iterator & operator -- ()
            {
                // check if ptr is not NULL
                if (ptr)
                {
                    ptr--;
                }
                return *this;
            }
            // postfix decrement
            iterator operator -- (int postfix)
            {
                // check if ptr is not NULL
                if (ptr)
                {
                    iterator tmp(*this);
                    ptr--;
                    return tmp;
                }
                return *this;
            }
            
            friend iterator list<T>::insert(iterator & it, const T & data) throw(const char *);
            friend iterator list<T>::erase(iterator it);
        };
        
       
    };
    
    /*******************************************
     * LIST :: Default Constructor
     *******************************************/
    template <class T>
    list<T>::list()
    {
        pHead = NULL;
        pTail = NULL;
        numElements = 0;
    }
    
    /*******************************************
     * LIST :: Copy Constructor
     *******************************************/
    template <class T>
    list<T>::list(const list & rhs)
    {
        numElements = 0;
        
        if (rhs.pHead != NULL)
        {
            try
            {
                pHead = new node(rhs.pHead->data);
                numElements++;
                
                node * pCurrent = pHead;
                node * pSource = rhs.pHead;
                
                while (pSource->pNext)
                {
                    pSource = pSource->pNext;
                    pCurrent->pNext = new node(pSource->data);
                    pCurrent->pPrev = pSource->pPrev;
                    pCurrent = pCurrent->pNext;
                    numElements++;
                }
                // didn't need this line of code
                // not sure why though
//                pCurrent->pPrev = pSource->pPrev;
                pTail = pCurrent;
            }
            catch (bad_alloc)
            {
                throw "ERROR: unable to allocate a new node for a list";
            }
        }
    }
    
    /*******************************************
     * LIST :: Destructor
     *******************************************/
    template <class T>
    list<T>::~list()
    {
        while (pHead != NULL)
        {
            node *pDelete = pHead;
            pHead = pHead->pNext;
            delete pDelete;
        }
    }
    
    /*******************************************
     * LIST :: Assignment Operator
     *******************************************/
    template <class T>
    list<T> & list<T>::operator=(const list<T> &rhs)
    {
        // erase existing elements
        clear();
        
        // allocate new elements
        for (node * p = rhs.pHead; p; p->pNext)
        {
            push_back(p->data);
        }
        
        return *this;
    }
    
    /*******************************************
     * LIST :: Clear
     *******************************************/
    template <class T>
    void list<T>::clear()
    {
        // iterate throught every node of linked list
        while (pHead != NULL)
        {
            node *pDelete = pHead;
            pHead = pHead->pNext;
            
            delete pDelete;
            pDelete = NULL;
        }
        pTail = pHead;
        numElements = 0;
    }
    
    /*******************************************
     * LIST :: Push Front
     *******************************************/
    template <class T>
    void list<T>::push_front(const T t)
    {
        try
        {
            // create new node with user input data
            node *pNew = new node(t);
        
            // check if container is empty
            if (pHead == NULL)
            {
                pHead = pNew;
                pTail = pNew;
                numElements++;
            }
            else
            {
                pHead->pPrev = pNew;
                pNew->pNext = pHead;
                pHead = pNew;
                numElements++;
            }
        }
        catch (bad_alloc)
        {
            throw "ERROR: unable to allocate a new node for a list";
        }
    }
    
    /*******************************************
     * LIST :: Push Back
     *******************************************/
    template <class T>
    void list<T>::push_back(const T t)
    {
        try
        {
            // create new node with user input data
            node *pNew = new node(t);
            
            // check if container is empty
            if (pHead == NULL)
            {
                pHead = pNew;
                pTail = pNew;
                numElements++;
            }
            else
            {
                pTail->pNext = pNew;
                pNew->pPrev = pTail;
                pTail = pNew;
                numElements++;
            }
        }
        catch (bad_alloc)
        {
            throw "ERROR: unable to allocate a new node for a list";
        }
    }
    
    /*******************************************
     * LIST :: Pop Front
     *******************************************/
    template <class T>
    void list<T>::pop_front()
    {
        if (pHead)
        {
            // new node to keep track of pHead
            node *pDelete = pHead;
            cout << pDelete->data << endl;
            
            cout << "befor pHead " << pHead->data << endl;
            pHead = pHead->pNext;
            cout << "after pHead " << pHead->data << endl;
            // if more than one node
            if (pHead && pHead->pNext)
            {
                cout << pHead->pNext->pPrev->data << endl;
                pHead->pNext->pPrev = pHead;
            }
            pDelete = pHead->pPrev;
            pDelete->data = NULL;
            delete pDelete;
            pHead->pPrev = NULL;
            cout << "pDelete after NULL " << pDelete << endl;
            
            numElements--;
            
            if (pHead == NULL)
            {
                pTail = pHead;
            }
        }
    }
    
    /*******************************************
     * LIST :: Pop Back
     *******************************************/
    template <class T>
    void list<T>::pop_back()
    {
        if (pTail)
        {
            // new node to keep track of pTail
            node *pDelete = pTail;
            
            pTail = pTail->pPrev;
            if (pTail && pTail->pPrev)
            {
                pTail->pPrev->pNext = pTail;
            }
            delete pDelete;
            pDelete = NULL;
            
            numElements--;
            
            if (pTail == NULL)
            {
                pHead = pTail;
            }
        }
    }

    /*******************************************
     * LIST :: Front
     *******************************************/
    template <class T>
    T & list<T>::front() throw(const char *)
    {
        if (empty())
        {
            throw "Error: calling front on empty list.";
        }
        else
        {
            return pHead->data;
        }
    }
    
    /*******************************************
     * LIST :: Back
     *******************************************/
    template <class T>
    T & list<T>::back() throw(const char *)
    {
        if (empty())
        {
            throw "Error: calling back on empty list.";
        }
        else
        {
            return pTail->data;
        }
    }
    
    /*******************************************
     * LIST :: Insert
     *******************************************/
    template <class T>
    typename list<T>:: iterator list<T>::insert(iterator &it, const T & data) throw(const char *)
    {
        // create new node with user input data
        node *pNew = new node(data);
        
//        if (it != NULL)
//        {
//            // algorithm like insert() from linked list
//            // difference in that pNode now is "it"
//            pNew->pNext = it;
//            pNew->pPrev = it.pPrev;
//            it.pPrev = pNew;
//            if (pNew->pPrev)
//            {
//                pNew->pPrev->pNext = pNew;
//            }
//        }
        return pNew;
    }

//    /*******************************************
//     * LIST :: Erase
//     *******************************************/
//    template <class T>
//    iterator list<T>::erase(iterator it)
//    {
//
//    }
    
   
}
#endif /* list_h */

