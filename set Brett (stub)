//
//  set.h
//  Assignment 5
//
//  Created by Brett Mills on 2/3/19.
//  Copyright Â© 2019 Brett Mills. All rights reserved.
//

#ifndef set_h
#define set_h

#include <cstddef>
#include <iostream>

#ifdef UNIT_TESTING
int main(int argc, const char* argv[]);
#endif

namespace custom
{
    template <class T>
    class set
    {
    private:
        T * buffer;
        int numElements;
        int numCapacity;
        
        int  findIndex(const T & t) const;
        void resize(int newCapacity);
        
    public:
        // for testing purposes (queue tests)
        #ifdef UNIT_TESTING
        friend int ::main(int argc, const char* argv[]);
        #endif
        
        // define nested iterator class
        class iterator;
        
        set()  { buffer = NULL, numElements = 0, numCapacity = 0; }
        set(int newCapacity);
        set(const set & rhs);
        ~set() { clear(); }
        
        set & operator = (const set & rhs);
        
        int  size() { return numCapacity; }
        bool empty();
        void clear();
        
        // set specific functions
        iterator erase(iterator it);
        iterator find(T t);
        void insert(T t);
        
        set Union(const set & rhs);
        set intersection(const set & rhs);
        set difference(const set & rhs);
        
        iterator begin();
        iterator end();
        
    };
    
    /*******************************************
     * SET :: Iterator Class
     *******************************************/
    template <class T>
    class set<T>::iterator
    {
    private:
        T * p;
        
    public:
        // constructors, destructors, and assignment operator
        iterator()      : p(NULL)      {              }
        iterator(T * p) : p(p)         {              }
        iterator(const iterator & rhs) { *this = rhs; }
        iterator & operator = (const iterator & rhs)
        {
            this->p = rhs.p;
            return *this;
        }
        // equals, not equals operator
        bool operator != (const iterator & rhs) const { return rhs.p != this->p; }
        bool operator == (const iterator & rhs) const { return rhs.p == this->p; }

        // prefix increment
        iterator & operator ++ ()
        {
            p++;
            return *this;
        }
        // postfix increment
        iterator operator ++ (int postfix)
        {
            iterator tmp(*this);
            p++;
            return tmp;
        }
        // prefix decrement
        iterator & operator -- ()
        {
            p--;
            return *this;
        }
        // postfix decrement
        iterator operator -- (int postfix)
        {
            iterator tmp(*this);
            p--;
            return tmp;
        }
        
    };
    
    /*******************************************
     * SET :: Find
     *******************************************/
    template <class T>
    typename set<T>::iterator set<T>::find(T t)
    {
        int iBegin = 0;
        int iEnd = numElements - 1;
        
        while (iBegin <= iEnd)
        {
            int iMiddle = (iBegin + iEnd) / 2;
            if (t == buffer[iMiddle])
            {
                return iMiddle;
            }
            if (t < buffer[iMiddle])
            {
                iEnd = iMiddle - 1;
            }
            else
            {
                iBegin = iMiddle + 1;
            }
        }
        return numElements;
    }
    
    /*******************************************
     * SET :: Insert
     *******************************************/
    template <class T>
    void set<T>::insert(T t)
    {
        
    }
}

#endif /* set_h */
